import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';

import 'package:native_ai_bridge/annotations/tool_annotations.dart';

/// Generator that creates Tool classes from annotated model classes.
class ToolGenerator extends GeneratorForAnnotation<GenerateTool> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        'The @GenerateTool annotation can only be applied to classes.',
        element: element,
      );
    }

    final classElement = element;

    if (classElement.isAbstract) {
      throw InvalidGenerationSourceError(
        'The @GenerateTool annotation cannot be applied to abstract classes.',
        element: element,
      );
    }

    return _generateToolClass(classElement, annotation);
  }

  String _generateToolClass(
    ClassElement classElement,
    ConstantReader annotation,
  ) {
    final className = classElement.name;
    final toolName = _getToolName(annotation, className);
    final toolDescription = _getToolDescription(annotation, className);
    final arguments = _generateArguments(classElement);

    final buffer = StringBuffer();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY MANUALLY');
    buffer.writeln('// This file was generated by native_ai_bridge_generator');
    buffer.writeln();
    buffer.writeln(
      'import \'package:native_ai_bridge/models/tool.dart\';',
    );
    buffer.writeln(
      'import \'package:native_ai_bridge/models/tool_argument.dart\';',
    );
    buffer.writeln(
      'import \'package:native_ai_bridge/enums/tool_argument_type.dart\';',
    );
    buffer.writeln();
    buffer.writeln('/// Generated Tool class for $className');
    buffer.writeln('class ${className}Tool extends BaseTool {');
    buffer.writeln('  ${className}Tool()');
    buffer.writeln('      : super(');
    buffer.writeln('          name: \'$toolName\',');
    buffer.writeln('          description: \'$toolDescription\',');
    buffer.writeln('          arguments: [');
    buffer.writeln(arguments);
    buffer.writeln('          ],');
    buffer.writeln('        );');
    buffer.writeln('}');

    return buffer.toString();
  }

  String _getToolName(ConstantReader annotation, String className) {
    final nameValue = annotation.read('name');
    if (nameValue.isNull) {
      return _pascalToSnakeCase(className);
    }
    return nameValue.stringValue;
  }

  String _getToolDescription(ConstantReader annotation, String className) {
    final descriptionValue = annotation.read('description');
    if (descriptionValue.isNull) {
      return 'Tool for $className';
    }
    return descriptionValue.stringValue;
  }

  String _generateArguments(ClassElement classElement) {
    final fields = classElement.fields
        .where((field) => !field.isStatic && !field.isSynthetic)
        .toList();

    if (fields.isEmpty) {
      return '';
    }

    final buffer = StringBuffer();
    for (var i = 0; i < fields.length; i++) {
      final field = fields[i];
      final argument = _generateArgument(field);
      if (argument != null) {
        buffer.writeln(
          '            $argument${i < fields.length - 1 ? ',' : ''}',
        );
      }
    }

    return buffer.toString();
  }

  String? _generateArgument(FieldElement field) {
    final annotation = _getToolArgumentAnnotation(field);
    if (annotation != null && annotation.read('exclude').boolValue) {
      return null;
    }

    final fieldName = field.name;
    final fieldType = field.type;
    final isNullable =
        fieldType.nullabilitySuffix == NullabilitySuffix.question;
    final argumentType = _mapDartTypeToToolArgumentType(fieldType);

    if (argumentType == null) {
      return null; // Skip unsupported types
    }

    final description = _getArgumentDescription(annotation, fieldName);
    final isOptional = _getIsOptional(annotation, isNullable);
    final constraints = _getConstraints(annotation);

    final buffer = StringBuffer();
    buffer.write('BaseToolArgument(');
    buffer.write('name: \'$fieldName\', ');
    buffer.write('type: ToolArgumentType.$argumentType, ');
    buffer.write('description: \'$description\', ');
    buffer.write('isOptional: $isOptional');
    if (constraints != null && constraints.isNotEmpty) {
      buffer.write(', constraints: $constraints');
    }
    buffer.write(')');

    return buffer.toString();
  }

  ConstantReader? _getToolArgumentAnnotation(FieldElement field) {
    final annotations = field.metadata;
    for (final annotation in annotations) {
      final element = annotation.element;
      if (element is ConstructorElement) {
        final annotationType = element.enclosingElement;
        if (annotationType.name == 'GenerateToolArgument') {
          return ConstantReader(annotation.computeConstantValue());
        }
      }
    }
    return null;
  }

  String? _mapDartTypeToToolArgumentType(DartType dartType) {
    // Get the non-nullable type for type checking
    final type = dartType.nullabilitySuffix == NullabilitySuffix.question
        ? (dartType as dynamic).promotedBound ?? dartType
        : dartType;

    if (type.isDartCoreString) {
      return 'string';
    } else if (type.isDartCoreInt) {
      return 'integer';
    } else if (type.isDartCoreDouble) {
      return 'double_';
    } else if (type.isDartCoreBool) {
      return 'boolean';
    } else if (type is InterfaceType) {
      // Handle List types
      if (type.element.name == 'List') {
        final typeArguments = type.typeArguments;
        if (typeArguments.isNotEmpty) {
          final innerType = typeArguments.first;
          if (innerType.isDartCoreString) {
            return 'string'; // List<String> -> string (array of strings)
          }
        }
      }
      // Handle Map types
      if (type.element.name == 'Map') {
        return 'string'; // Map -> string (JSON representation)
      }
    }

    return null; // Unsupported type
  }

  String _getArgumentDescription(ConstantReader? annotation, String fieldName) {
    if (annotation != null) {
      final descriptionValue = annotation.read('description');
      if (!descriptionValue.isNull) {
        return descriptionValue.stringValue;
      }
    }
    return _capitalizeFirst(
      fieldName
          .replaceAllMapped(
            RegExp(r'([A-Z])'),
            (match) => ' ${match.group(1)!.toLowerCase()}',
          )
          .trim(),
    );
  }

  bool _getIsOptional(ConstantReader? annotation, bool isNullable) {
    if (annotation != null) {
      final isOptionalValue = annotation.read('isOptional');
      if (!isOptionalValue.isNull) {
        return isOptionalValue.boolValue;
      }
    }
    return isNullable;
  }

  String? _getConstraints(ConstantReader? annotation) {
    if (annotation == null) {
      return null;
    }

    final constraintsValue = annotation.read('constraints');
    if (constraintsValue.isNull) {
      return null;
    }

    final constantValue = constraintsValue.objectValue;

    final buffer = StringBuffer();
    buffer.write('{');
    final map = constantValue.toMapValue();
    if (map != null) {
      final entries = map.entries.toList();
      for (var i = 0; i < entries.length; i++) {
        final entry = entries[i];
        final key = entry.key?.toStringValue() ?? '';
        final value = entry.value;
        buffer.write('\'$key\': ');
        final valueType = value?.type;
        if (valueType != null) {
          if (valueType.isDartCoreString) {
            buffer.write('\'${value!.toStringValue()}\'');
          } else if (valueType.isDartCoreInt) {
            buffer.write(value!.toIntValue());
          } else if (valueType.isDartCoreDouble) {
            buffer.write(value!.toDoubleValue());
          } else if (valueType.isDartCoreBool) {
            buffer.write(value!.toBoolValue());
          }
        }
        if (i < entries.length - 1) {
          buffer.write(', ');
        }
      }
    }
    buffer.write('}');

    return buffer.toString();
  }

  String _pascalToSnakeCase(String pascalCase) {
    return pascalCase.replaceAllMapped(RegExp(r'([A-Z])'), (match) {
      final index = match.start;
      return index > 0
          ? '_${match.group(1)!.toLowerCase()}'
          : match.group(1)!.toLowerCase();
    }).toLowerCase();
  }

  String _capitalizeFirst(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }
}
